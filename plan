int						d/i
size_t					z

octal					o
hexadecimal (LC)		x
hexadecimal (UC)		X

float/double			f

char					c

char *					s
pointer address			p

nb of chars written		n

flags:

h = short (d & i), unsigned short (o, u, x, X)
hh = signed char (d & i), unsigned char (o, u, x, X)
l = long (d & i), unsigned long (o, u, x, X)
ll = long long (d & i), unsigned long long (o, u, x, X)
L = long double (f)


PSEUDO CODE:

ft_printf (formar *str, args)
	char *str;
	char *trav
	va_list args
	
	va_start(format, args)
	str = parse_format_str(trav, va_list);
	va_end(args)
	return (print_string(str));

parse_format_str(char *trav, va_list)
	declare *struct
	declare *str

	struct = arguments_to_list(trav)
	str = parse_arguments(struct, va_list, trav)
	return (str);

arguments_to_list(char *trav)
	declare *structStart
	declare *structPTR
	int i

	structStart = malloc(sizeof(struct))
	structPTR = StructStart
	while(trav[i])
		if (%%)
			i++;
		else if (%)
			put_to_list(trav, i, structPTR)
			struct->len = i - 1
			i = struct->end_index
		i++
	if (structStart->mod == NULL)
		structStart->str = trav
	return (structStart)

put_to_list(char *trav, int i, struct)

	if (struct != NULL)
		struct->next = malloc(sizeof(struct))
		struct = struct->next
	while (struct->mod != NULL)
		if (!(struct->flag))
			check_flags(trav, i, struct)
			(i = struct->end_index)
		if (!(struct->precision))
			check_precision(trav, i, struct)
			(i = struct->end_index)
		if (!(struct->len_mod))
			check_length_modifier(trav, i, struct)
			(i = struct->end_index)
		if (check_modifier(trav[i]))
			struct->mod = trav[i]
			struct->end_index = i
		i++;
	return (struct);

void check_flags(char *trav, int i, struct) // MAKE IF-STATEMENTS INTO ARRAY?
	char *flags_arr = '#0-+ '
	int x

	while (flags_arr[x])
		if (trav[i] == flags_arr[x])
			struct->flag = x;
			

(	if (trav[i] == HASH)
		struct->hash = 1;
		return (struct->hash)
	if (trav[i] == ZERO)
		struct->zero = 1;
		return (struct->zero)
	if (trav[i] == MINUS)
		struct->minus = 1;
		return (struct->minus)
	if (trav[i] == PLUS)
		struct->plus = 1;
		return (struct->plus)
	if (trav[i] == SPACE)
		struct->space = 1;
		return (struct->space)
)

void check_precision(char *trav, int i, struct)
	if (trav[i] == '.')
		struct->precision = trav[i + 1] // loop for getting bigger num

void check_length_modifier(char *trav, int i, struct)
	if (trav[i] == 'h')
		if (trav[i + 1] = 'h')
			struct->len_mod = 2;
		else
			struct->len_mod = 1;
	if (trav[i] == 'l')
		if (trav[i + 1] == 'l')
			struct->len_mod = 3;
		else
			struct->len_mod = 4;

void check_modifier(char *trav, int i, struct)
	char *modifiers = "diouxXcspf"
	int x

	while (modifiers[x])
		if (modifiers[x] == trav[i])
			struct->modifier = modifiers[x]
	if (struct->modifiers != NULL)
		print_error
		return (NULL)

parse_arguments(struct, va_list, char *trav)
	char *str
	char *temp

	str = ft_strnew(struct->len)
	ft_strncpy(str, trav, len)
	while (struct)
		temp = get_argument(struct, va_list)
		ft_strjoin(str, temp)
		free(temp)
		struct = struct->next
	str = check_for_percentage_signs(str)
	return (str)

check_for_percentage_signs(char *str)
	int i;

	while (str[i])
		if (%%)
			str = remove_percentage(str, i)
		i++
	return (str)

remove_percentage(char *str, int i)
	char *temp

	temp = ft_strnew(ft_strlen(str - 1))
	ft_strncpy(temp, str, i)
	ft_strjoin(temp, str + i + 1 (/2?))
	return (temp)

print_string(char *str)
	int num
	
	num = ft_strlen(str)
	ft_putendl(str)
	return (num)